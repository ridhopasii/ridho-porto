const fs = require('fs');
const path = require('path');
const { createClient } = require('@supabase/supabase-js');

// Init Supabase
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY; // Must use Service Role for uploads without RLS issues usually

let supabase;
if (supabaseUrl && supabaseKey) {
  supabase = createClient(supabaseUrl, supabaseKey);
}

const isSupabaseEnabled = () => {
  return process.env.USE_SUPABASE === 'true' || process.env.NODE_ENV === 'production';
};

/**
 * Uploads a file to storage (Local or Supabase)
 * @param {Object} file - Multer file object
 * @param {String} folder - Storage bucket folder (e.g. 'articles', 'projects')
 * @returns {Promise<String>} - The public URL of the uploaded file
 */
async function uploadFile(file, folder = 'misc') {
  // Use Supabase if enabled or in production (Vercel)
  if (isSupabaseEnabled() && supabase) {
    try {
      const fileContent = fs.readFileSync(file.path);
      // Create a clean filename
      const fileExt = path.extname(file.originalname);
      const fileName = `${folder}/${Date.now()}-${Math.round(Math.random() * 1E9)}${fileExt}`;

      const { data, error } = await supabase
        .storage
        .from('uploads') // Bucket name MUST be 'uploads' and PUBLIC
        .upload(fileName, fileContent, {
          contentType: file.mimetype,
          upsert: false
        });

      if (error) throw error;

      // Get Public URL
      const { data: { publicUrl } } = supabase
        .storage
        .from('uploads')
        .getPublicUrl(fileName);

      return publicUrl;
    } catch (err) {
      console.error('Supabase upload error:', err);
      // Fallback to local if allowed, but in Vercel this is fatal.
      // For now, let's allow fallback only if NOT in production
      if (process.env.NODE_ENV === 'production') throw err;
    }
  }

  // Fallback to local storage
  try {
    const uploadDir = path.join(__dirname, '../../public/uploads');

    // Ensure directory exists
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }

    // Keep the filename generated by multer or imageOptimizer (which sets file.filename)
    // If we came from imageOptimizer, file.filename has .webp.
    // If not, multer generated 'uniqueSuffix + ext' in `middleware/upload.js`.
    // Let's rely on file.filename being correct.
    const targetPath = path.join(uploadDir, file.filename);

    // Prepare content
    // Check if file.path exists (it should)
    if (fs.existsSync(file.path)) {
      // Move or Copy
      try {
        fs.renameSync(file.path, targetPath);
      } catch (e) {
        fs.copyFileSync(file.path, targetPath);
        try { fs.unlinkSync(file.path); } catch (_) { }
      }
    } else {
      // Did it come from buffer or something? Multer diskStorage always has path.
      // If imageOptimizer was used, it created a file at file.path.
      console.error('File path not found:', file.path);
      return null;
    }

    return '/uploads/' + file.filename;
  } catch (localError) {
    console.error('Local file save error:', localError);
    return null; // Failed
  }
}

module.exports = {
  uploadFile,
  uploadLocalFileToSupabase: uploadFile,
  isSupabaseEnabled
};
